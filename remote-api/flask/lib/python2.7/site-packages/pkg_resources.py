"""
Package resource API
--------------------

A resource is a logical file contained within a package, or a logical
subdirectory thereof.  The package resource API expects resource names
to have their path parts separated with ``/``, *not* whatever the local
path separator is.  Do not use os.path operations to manipulate resource
names being passed into the API.

The package resource API is designed to work with normal filesystem packages,
.egg files, and unpacked .egg files.  It can also work in a limited way with
.zip files and with custom PEP 302 loaders that support the ``get_data()``
method.
"""

import sys
import os
import time
import re
import imp
import zipfile
import zipimport
import warnings
import stat
import functools
import pkgutil
import token
import symbol
import operator
import platform
from pkgutil import get_importer

try:
    from urlparse import urlparse, urlunparse
except ImportError:
    from urllib.parse import urlparse, urlunparse

try:
    frozenset
except NameError:
    from sets import ImmutableSet as frozenset
try:
    basestring
    next = lambda o: o.next()
    from cStringIO import StringIO as BytesIO
except NameError:
    basestring = str
    from io import BytesIO
    def execfile(fn, globs=None, locs=None):
        if globs is None:
            globs = globals()
        if locs is None:
            locs = globs
        exec(compile(open(fn).read(), fn, 'exec'), globs, locs)

# capture these to bypass sandboxing
from os import utime
try:
    from os import mkdir, rename, unlink
    WRITE_SUPPORT = True
except ImportError:
    # no write support, probably under GAE
    WRITE_SUPPORT = False

from os import open as os_open
from os.path import isdir, split

# Avoid try/except due to potential problems with delayed import mechanisms.
if sys.version_info >= (3, 3) and sys.implementation.name == "cpython":
    import importlib._bootstrap as importlib_bootstrap
else:
    importlib_bootstrap = None

try:
    import parser
except ImportError:
    pass

def _bypass_ensure_directory(name, mode=0x1FF):  # 0777
    # Sandbox-bypassing version of ensure_directory()
    if not WRITE_SUPPORT:
        raise IOError('"os.mkdir" not supported on this platform.')
    dirname, filename = split(name)
    if dirname and filename and not isdir(dirname):
        _bypass_ensure_directory(dirname)
        mkdir(dirname, mode)


_state_vars = {}

def _declare_state(vartype, **kw):
    g = globals()
    for name, val in kw.items():
        g[name] = val
        _state_vars[name] = vartype

def __getstate__():
    state = {}
    g = globals()
    for k, v in _state_vars.items():
        state[k] = g['_sget_'+v](g[k])
    return state

def __setstate__(state):
    g = globals()
    for k, v in state.items():
        g['_sset_'+_state_vars[k]](k, g[k], v)
    return state

def _sget_dict(val):
    return val.copy()

def _sset_dict(key, ob, state):
    ob.clear()
    ob.update(state)

def _sget_object(val):
    return val.__getstate__()

def _sset_object(key, ob, state):
    ob.__setstate__(state)

_sget_none = _sset_none = lambda *args: None


def get_supported_platform():
    """Return this platform's maximum compatible version.

    distutils.util.get_platform() normally reports the minimum version
    of Mac OS X that would be required to *use* extensions produced by
    distutils.  But what we want when checking compatibility is to know the
    version of Mac OS X that we are *running*.  To allow usage of packages that
    explicitly require a newer version of Mac OS X, we must also know the
    current version of the OS.

    If this condition occurs for any other platform with a version in its
    platform strings, this function should be extended accordingly.
    """
    plat = get_build_platform()
    m = macosVersionString.match(plat)
    if m is not None and sys.platform == "darwin":
        try:
            plat = 'macosx-%s-%s' % ('.'.join(_macosx_vers()[:2]), m.group(3))
        except ValueError:
            pass    # not Mac OS X
    return plat

__all__ = [
    # Basic resource access and distribution/entry point discovery
    'require', 'run_script', 'get_provider',  'get_distribution',
    'load_entry_point', 'get_entry_map', 'get_entry_info', 'iter_entry_points',
    'resource_string', 'resource_stream', 'resource_filename',
    'resource_listdir', 'resource_exists', 'resource_isdir',

    # Environmental control
    'declare_namespace', 'working_set', 'add_activation_listener',
    'find_distributions', 'set_extraction_path', 'cleanup_resources',
    'get_default_cache',

    # Primary implementation classes
    'Environment', 'WorkingSet', 'ResourceManager',
    'Distribution', 'Requirement', 'EntryPoint',

    # Exceptions
    'ResolutionError','VersionConflict','DistributionNotFound','UnknownExtra',
    'ExtractionError',

    # Parsing functions and string utilities
    'parse_requirements', 'parse_version', 'safe_name', 'safe_version',
    'get_platform', 'compatible_platforms', 'yield_lines', 'split_sections',
    'safe_extra', 'to_filename', 'invalid_marker', 'evaluate_marker',

    # filesystem utilities
    'ensure_directory', 'normalize_path',

    # Distribution "precedence" constants
    'EGG_DIST', 'BINARY_DIST', 'SOURCE_DIST', 'CHECKOUT_DIST', 'DEVELOP_DIST',

    # "Provider" interfaces, implementations, and registration/lookup APIs
    'IMetadataProvider', 'IResourceProvider', 'FileMetadata',
    'PathMetadata', 'EggMetadata', 'EmptyProvider', 'empty_provider',
    'NullProvider', 'EggProvider', 'DefaultProvider', 'ZipProvider',
    'register_finder', 'register_namespace_handler', 'register_loader_type',
    'fixup_namespace_packages', 'get_importer',

    # Deprecated/backward compatibility only
    'run_main', 'AvailableDistributions',
]

class ResolutionError(Exception):
    """Abstract base for dependency resolution errors"""
    def __repr__(self):
        return self.__class__.__name__+repr(self.args)

class VersionConflict(ResolutionError):
    """An already-installed version conflicts with the requested version"""

class DistributionNotFound(ResolutionError):
    """A requested distribution was not found"""

class UnknownExtra(ResolutionError):
    """Distribution doesn't have an "extra feature" of the given name"""
_provider_factories = {}

PY_MAJOR = sys.version[:3]
EGG_DIST = 3
BINARY_DIST = 2
SOURCE_DIST = 1
CHECKOUT_DIST = 0
DEVELOP_DIST = -1

def register_loader_type(loader_type, provider_factory):
    """Register `provider_factory` to make providers for `loader_type`

    `loader_type` is the type or class of a PEP 302 ``module.__loader__``,
    and `provider_factory` is a function that, passed a *module* object,
    returns an ``IResourceProvider`` for that module.
    """
    _provider_factories[loader_type] = provider_factory

def get_provider(moduleOrReq):
    """Return an IResourceProvider for the named module or requirement"""
    if isinstance(moduleOrReq,Requirement):
        return working_set.find(moduleOrReq) or require(str(moduleOrReq))[0]
    try:
        module = sys.modules[moduleOrReq]
    except KeyError:
        __import__(moduleOrReq)
        module = sys.modules[moduleOrReq]
    loader = getattr(module, '__loader__', None)
    return _find_adapter(_provider_factories, loader)(module)

def _macosx_vers(_cache=[]):
    if not _cache:
        import platform
        version = platform.mac_ver()[0]
        # fallback for MacPorts
        if version == '':
            import plistlib
            plist = '/System/Library/CoreServices/SystemVersion.plist'
            if os.path.exists(plist):
                if hasattr(plistlib, 'readPlist'):
                    plist_content = plistlib.readPlist(plist)
                    if 'ProductVersion' in plist_content:
                        version = plist_content['ProductVersion']

        _cache.append(version.split('.'))
    return _cache[0]

def _macosx_arch(machine):
    return {'PowerPC':'ppc', 'Power_Macintosh':'ppc'}.get(machine,machine)

def get_build_platform():
    """Return this platform's string for platform-specific distributions

    XXX Currently this is the same as ``distutils.util.get_platform()``, but it
    needs some hacks for Linux and Mac OS X.
    """
    try:
        # Python 2.7 or >=3.2
        from sysconfig import get_platform
    except ImportError:
        from distutils.util import get_platform

    plat = get_platform()
    if sys.platform == "darwin" and not plat.startswith('macosx-'):
        try:
            version = _macosx_vers()
            machine = os.uname()[4].replace(" ", "_")
            return "macosx-%d.%d-%s" % (int(version[0]), int(version[1]),
                _macosx_arch(machine))
        except ValueError:
            # if someone is running a non-Mac darwin system, this will fall
            # through to the default implementation
            pass
    return plat

macosVersionString = re.compile(r"macosx-(\d+)\.(\d+)-(.*)")
darwinVersionString = re.compile(r"darwin-(\d+)\.(\d+)\.(\d+)-(.*)")
get_platform = get_build_platform   # XXX backward compat


def compatible_platforms(provided,required):
    """Can code for the `provided` platform run on the `required` platform?

    Returns true if either platform is ``None``, or the platforms are equal.

    XXX Needs compatibility checks for Linux and other unixy OSes.
    """
    if provided is None or required is None or provided==required:
        return True     # easy case

    # Mac OS X special cases
    reqMac = macosVersionString.match(required)
    if reqMac:
        provMac = macosVersionString.match(provided)

        # is this a Mac package?
        if not provMac:
            # this is backwards compatibility for packages built before
            # setuptools 0.6. All packages built after this point will
            # use the new macosx designation.
            provDarwin = darwinVersionString.match(provided)
            if provDarwin:
                dversion = int(provDarwin.group(1))
                macosversion = "%s.%s" % (reqMac.group(1), reqMac.group(2))
                if dversion == 7 and macosversion >= "10.3" or \
                        dversion == 8 and macosversion >= "10.4":

                    #import warnings
                    #warnings.warn("Mac eggs should be rebuilt to "
                    #    "use the macosx designation instead of darwin.",
                    #    category=DeprecationWarning)
                    return True
            return False    # egg isn't macosx or legacy darwin

        # are they the same major version and machine type?
        if provMac.group(1) != reqMac.group(1) or \
                provMac.group(3) != reqMac.group(3):
            return False

        # is the required OS major update >= the provided one?
        if int(provMac.group(2)) > int(reqMac.group(2)):
            return False

        return True

    # XXX Linux and other platforms' special cases should go here
    return False


def run_script(dist_spec, script_name):
    """Locate distribution `dist_spec` and run its `script_name` script"""
    ns = sys._getframe(1).f_globals
    name = ns['__name__']
    ns.clear()
    ns['__name__'] = name
    require(dist_spec)[0].run_script(script_name, ns)

run_main = run_script   # backward compatibility

def get_distribution(dist):
    """Return a current distribution object for a Requirement or string"""
    if isinstance(dist,basestring): dist = Requirement.parse(dist)
    if isinstance(dist,Requirement): dist = get_provider(dist)
    if not isinstance(dist,Distribution):
        raise TypeError("Expected string, Requirement, or Distribution", dist)
    return dist

def load_entry_point(dist, group, name):
    """Return `name` entry point of `group` for `dist` or raise ImportError"""
    return get_distribution(dist).load_entry_point(group, name)

def get_entry_map(dist, group=None):
    """Return the entry point map for `group`, or the full entry map"""
    return get_distribution(dist).get_entry_map(group)

def get_entry_info(dist, group, name):
    """Return the EntryPoint object for `group`+`name`, or ``None``"""
    return get_distribution(dist).get_entry_info(group, name)


class IMetadataProvider:

    def has_metadata(name):
        """Does the package's distribution contain the named metadata?"""

    def get_metadata(name):
        """The named metadata resource as a string"""

    def get_metadata_lines(name):
        """Yield named metadata resource as list of non-blank non-comment lines

       Leading and trailing whitespace is stripped from each line, and lines
       with ``#`` as the first non-blank character are omitted."""

    def metadata_isdir(name):
        """Is the named metadata a directory?  (like ``os.path.isdir()``)"""

    def metadata_listdir(name):
        """List of metadata names in the directory (like ``os.listdir()``)"""

    def run_script(script_name, namespace):
        """Execute the named script in the supplied namespace dictionary"""


class IResourceProvider(IMetadataProvider):
    """An object that provides access to package resources"""

    def get_resource_filename(manager, resource_name):
        """Return a true filesystem path for `resource_name`

        `manager` must be an ``IResourceManager``"""

    def get_resource_stream(manager, resource_name):
        """Return a readable file-like object for `resource_name`

        `manager` must be an ``IResourceManager``"""

    def get_resource_string(manager, resource_name):
        """Return a string containing the contents of `resource_name`

        `manager` must be an ``IResourceManager``"""

    def has_resource(resource_name):
        """Does the package contain the named resource?"""

    def resource_isdir(resource_name):
        """Is the named resource a directory?  (like ``os.path.isdir()``)"""

    def resource_listdir(resource_name):
        """List of resource names in the directory (like ``os.listdir()``)"""


class WorkingSet(object):
    """A collection of active distributions on sys.path (or a similar list)"""

    def __init__(self, entries=None):
        """Create working set from list of path entries (default=sys.path)"""
        self.entries = []
        self.entry_keys = {}
        self.by_key = {}
        self.callbacks = []

        if entries is None:
            entries = sys.path

        for entry in entries:
            self.add_entry(entry)

    def add_entry(self, entry):
        """Add a path item to ``.entries``, finding any distributions on it

        ``find_distributions(entry, True)`` is used to find distributions
        corresponding to the path entry, and they are added.  `entry` is
        always appended to ``.entries``, even if it is already present.
        (This is because ``sys.path`` can contain the same value more than
        once, and the ``.entries`` of the ``sys.path`` WorkingSet should always
        equal ``sys.path``.)
        """
        self.entry_keys.setdefault(entry, [])
        self.entries.append(entry)
        for dist in find_distributions(entry, True):
            self.add(dist, entry, False)

    def __contains__(self,dist):
        """True if `dist` is the active distribution for its project"""
        return self.by_key.get(dist.key) == dist

    def find(self, req):
        """Find a distribution matching requirement `req`

        If there is an active distribution for the requested project, this
        returns it as long as it meets the version requirement specified by
        `req`.  But, if there is an active distribution for the project and it
        does *not* meet the `req` requirement, ``VersionConflict`` is raised.
        If there is no active distribution for the requested project, ``None``
        is returned.
        """
        dist = self.by_key.get(req.key)
        if dist is not None and dist not in req:
            raise VersionConflict(dist,req)     # XXX add more info
        else:
            return dist

    def iter_entry_points(self, group, name=None):
        """Yield entry point objects from `group` matching `name`

        If `name` is None, yields all entry points in `group` from all
        distributions in the working set, otherwise only ones matching
        both `group` and `name` are yielded (in distribution order).
        """
        for dist in self:
            entries = dist.get_entry_map(group)
            if name is None:
                for ep in entries.values():
                    yield ep
            elif name in entries:
                yield entries[name]

    def run_script(self, requires, script_name):
        """Locate distribution for `requires` and run `script_name` script"""
        ns = sys._getframe(1).f_globals
        name = ns['__name__']
        ns.clear()
        ns['__name__'] = name
        self.require(requires)[0].run_script(script_name, ns)

    def __iter__(self):
        """Yield distributions for non-duplicate projects in the working set

        The yield order is the order in which the items' path entries were
        added to the working set.
        """
        seen = {}
        for item in self.entries:
            if item not in self.entry_keys:
                # workaround a cache issue
                continue

            for key in self.entry_keys[item]:
                if key not in seen:
                    seen[key]=1
                    yield self.by_key[key]

    def add(self, dist, entry=None, insert=True, replace=False):
        """Add `dist` to working set, associated with `entry`

        If `entry` is unspecified, it defaults to the ``.location`` of `dist`.
        On exit from this routine, `entry` is added to the end of the working
        set's ``.entries`` (if it wasn't already present).

        `dist` is only added to the working set if it's for a project that
        doesn't already have a distribution in the set, unless `replace=True`.
        If it's added, any callbacks registered with the ``subscribe()`` method
        will be called.
        """
        if insert:
            dist.insert_on(self.entries, entry)

        if entry is None:
            entry = dist.location
        keys = self.entry_keys.setdefault(entry,[])
        keys2 = self.entry_keys.setdefault(dist.location,[])
        if not replace and dist.key in self.by_key:
            return      # ignore hidden distros

        self.by_key[dist.key] = dist
        if dist.key not in keys:
            keys.append(dist.key)
        if dist.key not in keys2:
            keys2.append(dist.key)
        self._added_new(dist)

    def resolve(self, requirements, env=None, installer=None,
            replace_conflicting=False):
        """List all distributions needed to (recursively) meet `requirements`

        `requirements` must be a sequence of ``Requirement`` objects.  `env`,
        if supplied, should be an ``Environment`` instance.  If
        not supplied, it defaults to all distributions available within any
        entry or distribution in the working set.  `installer`, if supplied,
        will be invoked with each requirement that cannot be met by an
        already-installed distribution; it should return a ``Distribution`` or
        ``None``.

        Unless `replace_conflicting=True`, raises a VersionConflict exception if
        any requirements are found on the path that have the correct name but
        the wrong version.  Otherwise, if an `installer` is supplied it will be
        invoked to obtain the correct version of the requirement and activate
        it.
        """

        requirements = list(requirements)[::-1]  # set up the stack
        processed = {}  # set of processed requirements
        best = {}  # key -> dist
        to_activate = []

        while requirements:
            req = requirements.pop(0)   # process dependencies breadth-first
            if req in processed:
                # Ignore cyclic or redundant dependencies
                continue
            dist = best.get(req.key)
            if dist is None:
                # Find the best distribution and add it to the map
                dist = self.by_key.get(req.key)
                if dist is None or (dist not in req and replace_conflicting):
                    ws = self
                    if env is None:
                        if dist is None:
                            env = Environment(self.entries)
                        else:
                            # Use an empty environment and workingset to avoid
                            # any further conflicts with the conflicting
                            # distribution
                            env = Environment([])
                            ws = WorkingSet([])
                    dist = best[req.key] = env.best_match(req, ws, installer)
                    if dist is None:
                        #msg = ("The '%s' distribution was not found on this "
                        #       "system, and is required by this application.")
                        #raise DistributionNotFound(msg % req)

                        # unfortunately, zc.buildout uses a str(err)
                        # to get the name of the distribution here..
                        raise DistributionNotFound(req)
                to_activate.append(dist)
            if dist not in req:
                # Oops, the "best" so far conflicts with a dependency
                raise VersionConflict(dist,req) # XXX put more info here
            requirements.extend(dist.requires(req.extras)[::-1])
            processed[req] = True

        return to_activate    # return list of distros to activate

    def find_plugins(self, plugin_env, full_env=None, installer=None,
            fallback=True):
        """Find all activatable distributions in `plugin_env`

        Example usage::

            distributions, errors = working_set.find_plugins(
                Environment(plugin_dirlist)
            )
            map(working_set.add, distributions)  # add plugins+libs to sys.path
            print 'Could not load', errors        # display errors

        The `plugin_env` should be an ``Environment`` instance that contains
        only distributions that are in the project's "plugin directory" or
        directories. The `full_env`, if supplied, should be an ``Environment``
        contains all currently-available distributions.  If `full_env` is not
        supplied, one is created automatically from the ``WorkingSet`` this
        method is called on, which will typically mean that every directory on
        ``sys.path`` will be scanned for distributions.

        `installer` is a standard installer callback as used by the
        ``resolve()`` method. The `fallback` flag indicates whether we should
        attempt to resolve older versions of a plugin if the newest version
        cannot be resolved.

        This method returns a 2-tuple: (`distributions`, `error_info`), where
        `distributions` is a list of the distributions found in `plugin_env`
        that were loadable, along with any other distributions that are needed
        to resolve their dependencies.  `error_info` is a dictionary mapping
        unloadable plugin distributions to an exception instance describing the
        error that occurred. Usually this will be a ``DistributionNotFound`` or
        ``VersionConflict`` instance.
        """

        plugin_projects = list(plugin_env)
        plugin_projects.sort()  # scan project names in alphabetic order

        error_info = {}
        distributions = {}

        if full_env is None:
            env = Environment(self.entries)
            env += plugin_env
        else:
            env = full_env + plugin_env

        shadow_set = self.__class__([])
        list(map(shadow_set.add, self))   # put all our entries in shadow_set

        for project_name in plugin_projects:

            for dist in plugin_env[project_name]:

                req = [dist.as_requirement()]

                try:
                    resolvees = shadow_set.resolve(req, env, installer)

                except ResolutionError:
                    v = sys.exc_info()[1]
                    error_info[dist] = v    # save error info
                    if fallback:
                        continue    # try the next older version of project
                    else:
                        break       # give up on this project, keep going

                else:
                    list(map(shadow_set.add, resolvees))
                    distributions.update(dict.fromkeys(resolvees))

                    # success, no need to try any more versions of this project
                    break

        distributions = list(distributions)
        distributions.sort()

        return distributions, error_info

    def require(self, *requirements):
        """Ensure that distributions matching `requirements` are activated

        `requirements` must be a string or a (possibly-nested) sequence
        thereof, specifying the distributions and versions required.  The
        return value is a sequence of the distributions that needed to be
        activated to fulfill the requirements; all relevant distributions are
        included, even if they were already activated in this working set.
        """
        needed = self.resolve(parse_requirements(requirements))

        for dist in needed:
            self.add(dist)

        return needed

    def subscribe(self, callback):
        """Invoke `callback` for all distributions (including existing ones)"""
        if callback in self.callbacks:
            return
        self.callbacks.append(callback)
        for dist in self:
            callback(dist)

    def _added_new(self, dist):
        for callback in self.callbacks:
            callback(dist)

    def __getstate__(self):
        return (
            self.entries[:], self.entry_keys.copy(), self.by_key.copy(),
            self.callbacks[:]
        )

    def __setstate__(self, e_k_b_c):
        entries, keys, by_key, callbacks = e_k_b_c
        self.entries = entries[:]
        self.entry_keys = keys.copy()
        self.by_key = by_key.copy()
        self.callbacks = callbacks[:]


class Environment(object):
    """Searchable snapshot of distributions on a search path"""

    def __init__(self, search_path=None, platform=get_supported_platform(), python=PY_MAJOR):
        """Snapshot distributions available on a search path

        Any distributions found on `search_path` are added to the environment.
        `search_path` should be a sequence of ``sys.path`` items.  If not
        supplied, ``sys.path`` is used.

        `platform` is an optional string specifying the name of the platform
        that platform-specific distributions must be compatible with.  If
        unspecified, it defaults to the current platform.  `python` is an
        optional string naming the desired version of Python (e.g. ``'3.3'``);
        it defaults to the current version.

        You may explicitly set `platform` (and/or `python`) to ``None`` if you
        wish to map *all* distributions, not just those compatible with the
        running platform or Python version.
        """
        self._distmap = {}
        self._cache = {}
        self.platform = platform
        self.python = python
        self.scan(search_path)

    def can_add(self, dist):
        """Is distribution `dist` acceptable for this environment?

        The distribution must match the platform and python version
        requirements specified when this environment was created, or False
        is returned.
        """
        return (self.python is None or dist.py_version is None
            or dist.py_version==self.python) \
            and compatible_platforms(dist.platform,self.platform)

    def remove(self, dist):
        """Remove `dist` from the environment"""
        self._distmap[dist.key].remove(dist)

    def scan(self, search_path=None):
        """Scan `search_path` for distributions usable in this environment

        Any distributions found are added to the environment.
        `search_path` should be a sequence of ``sys.path`` items.  If not
        supplied, ``sys.path`` is used.  Only distributions conforming to
        the platform/python version defined at initialization are added.
        """
        if search_path is None:
            search_path = sys.path

        for item in search_path:
            for dist in find_distributions(item):
                self.add(dist)

    def __getitem__(self,project_name):
        """Return a newest-to-oldest list of distributions for `project_name`
        """
        try:
            return self._cache[project_name]
        except KeyError:
            project_name = project_name.lower()
            if project_name not in self._distmap:
                return []

        if project_name not in self._cache:
            dists = self._cache[project_name] = self._distmap[project_name]
            _sort_dists(dists)

        return self._cache[project_name]

    def add(self,dist):
        """Add `dist` if we ``can_add()`` it and it isn't already added"""
        if self.can_add(dist) and dist.has_version():
            dists = self._distmap.setdefault(dist.key,[])
            if dist not in dists:
                dists.append(dist)
                if dist.key in self._cache:
                    _sort_dists(self._cache[dist.key])

    def best_match(self, req, working_set, installer=None):
        """Find distribution best matching `req` and usable on `working_set`

        This calls the ``find(req)`` method of the `working_set` to see if a
        suitable distribution is already active.  (This may raise
        ``VersionConflict`` if an unsuitable version of the project is already
        active in the specified `working_set`.)  If a suitable distribution
        isn't active, this method returns the newest distribution in the
        environment that meets the ``Requirement`` in `req`.  If no suitable
        distribution is found, and `installer` is supplied, then the result of
        calling the environment's ``obtain(req, installer)`` method will be
        returned.
        """
        dist = working_set.find(req)
        if dist is not None:
            return dist
        for dist in self[req.key]:
            if dist in req:
                return dist
        return self.obtain(req, installer) # try and download/install

    def obtain(self, requirement, installer=None):
        """Obtain a distribution matching `requirement` (e.g. via download)

        Obtain a distro that matches requirement (e.g. via download).  In the
        base ``Environment`` class, this routine just returns
        ``installer(requirement)``, unless `installer` is None, in which case
        None is returned instead.  This method is a hook that allows subclasses
        to attempt other ways of obtaining a distribution before falling back
        to the `installer` argument."""
        if installer is not None:
            return installer(requirement)

    def __iter__(self):
        """Yield the unique project names of the available distributions"""
        for key in self._distmap.keys():
            if self[key]: yield key

    def __iadd__(self, other):
        """In-place addition of a distribution or environment"""
        if isinstance(other,Distribution):
            self.add(other)
        elif isinstance(other,Environment):
            for project in other:
                for dist in other[project]:
                    self.add(dist)
        else:
            raise TypeError("Can't add %r to environment" % (other,))
        return self

    def __add__(self, other):
        """Add an environment or distribution to an environment"""
        new = self.__class__([], platform=None, python=None)
        for env in self, other:
            new += env
        return new


AvailableDistributions = Environment    # XXX backward compatibility


class ExtractionError(RuntimeError):
    """An error occurred extracting a resource

    The following attributes are available from instances of this exception:

    manager
        The resource manager that raised this exception

    cache_path
        The base directory for resource extraction

    original_error
        The exception instance that caused extraction to fail
    """


class ResourceManager:
    """Manage resource extraction and packages"""
    extraction_path = None

    def __init__(self):
        self.cached_files = {}

    def resource_exists(self, package_or_requirement, resource_name):
        """Does the named resource exist?"""
        return get_provider(package_or_requirement).has_resource(resource_name)

    def resource_isdir(self, package_or_requirement, resource_name):
        """Is the named resource an existing directory?"""
        return get_provider(package_or_requirement).resource_isdir(
            resource_name
        )

    def resource_filename(self, package_or_requirement, resource_name):
        """Return a true filesystem path for specified resource"""
        return get_provider(package_or_requirement).get_resource_filename(
            self, resource_name
        )

    def resource_stream(self, package_or_requirement, resource_name):
        """Return a readable file-like object for specified resource"""
        return get_provider(package_or_requirement).get_resource_stream(
            self, resource_name
        )

    def resource_string(self, package_or_requirement, resource_name):
        """Return specified resource as a string"""
        return get_provider(package_or_requirement).get_resource_string(
            self, resource_name
        )

    def resource_listdir(self, package_or_requirement, resource_name):
        """List the contents of the named resource directory"""
        return get_provider(package_or_requirement).resource_listdir(
            resource_name
        )

    def extraction_error(self):
        """Give an error message for problems extracting file(s)"""

        old_exc = sys.exc_info()[1]
        cache_path = self.extraction_path or get_default_cache()

        err = ExtractionError("""Can't extract file(s) to egg cache

The following error occurred while trying to extract file(s) to the Python egg
cache:

  %s

The Python egg cache directory is currently set to:

  %s

Perhaps your account does not have write access to this directory?  You can
change the cache directory by setting the PYTHON_EGG_CACHE environment
variable to point to an accessible directory.
""" % (old_exc, cache_path)
        )
        err.manager = self
        err.cache_path = cache_path
        err.original_error = old_exc
        raise err

    def get_cache_path(self, archive_name, names=()):
        """Return absolute location in cache for `archive_name` and `names`

        The parent directory of the resulting path will be created if it does
        not already exist.  `archive_name` should be the base filename of the
        enclosing egg (which may not be the name of the enclosing zipfile!),
        including its ".egg" extension.  `names`, if provided, should be a
        sequence of path name parts "under" the egg's extraction location.

        This method should only be called by resource providers that need to
        obtain an extraction location, and only for names they intend to
        extract, as it tracks the generated names for possible cleanup later.
        """
        extract_path = self.extraction_path or get_default_cache()
        target_path = os.path.join(extract_path, archive_name+'-tmp', *names)
        try:
            _bypass_ensure_directory(target_path)
        except:
            self.extraction_error()

        self._warn_unsafe_extraction_path(extract_path)

        self.cached_files[target_path] = 1
        return target_path

    @staticmethod
    def _warn_unsafe_extraction_path(path):
        """
        If the default extraction path is overridden and set to an insecure
        location, such as /tmp, it opens up an opportunity for an attacker to
        replace an extracted file with an unauthorized payload. Warn the user
        if a known insecure location is used.

        See Distribute #375 for more details.
        """
        if os.name == 'nt' and not path.startswith(os.environ['windir']):
            # On Windows, permissions are generally restrictive by default
            #  and temp directories are not writable by other users, so
            #  bypass the warning.
            return
        mode = os.stat(path).st_mode
        if mode & stat.S_IWOTH or mode & stat.S_IWGRP:
            msg = ("%s is writable by group/others and vulnerable to attack "
                "when "
                "used with get_resource_filename. Consider a more secure "
                "location (set with .set_extraction_path or the "
                "PYTHON_EGG_CACHE environment variable)." % path)
            warnings.warn(msg, UserWarning)

    def postprocess(self, tempname, filename):
        """Perform any platform-specific postprocessing of `tempname`

        This is where Mac header rewrites should be done; other platforms don't
        have anything special they should do.

        Resource providers should call this method ONLY after successfully
        extracting a compressed resource.  They must NOT call it on resources
        that are already in the filesystem.

        `tempname` is the current (temporary) name of the file, and `filename`
        is the name it will be renamed to by the caller after this routine
        returns.
        """

        if os.name == 'posix':
            # Make the resource executable
            mode = ((os.stat(tempname).st_mode) | 0x16D) & 0xFFF # 0555, 07777
            os.chmod(tempname, mode)

    def set_extraction_path(self, path):
        """Set the base path where resources will be extracted to, if needed.

        If you do not call this routine before any extractions take place, the
        path defaults to the return value of ``get_default_cache()``.  (Which
        is based on the ``PYTHON_EGG_CACHE`` environment variable, with various
        platform-specific fallbacks.  See that routine's documentation for more
        details.)

        Resources are extracted to subdirectories of this path based upon
        information given by the ``IResourceProvider``.  You may set this to a
        temporary directory, but then you must call ``cleanup_resources()`` to
        delete the extracted files when done.  There is no guarantee that
        ``cleanup_resources()`` will be able to remove all extracted files.

        (Note: you may not change the extraction path for a given resource
        manager once resources have been extracted, unless you first call
        ``cleanup_resources()``.)
        """
        if self.cached_files:
            raise ValueError(
                "Can't change extraction path, files already extracted"
            )

        self.extraction_path = path

    def cleanup_resources(self, force=False):
        """
        Delete all extracted resource files and directories, returning a list
        of the file and directory names that could not be successfully removed.
        This function does not have any concurrency protection, so it should
        generally only be called when the extraction path is a temporary
        directory exclusive to a single process.  This method is not
        automatically called; you must call it explicitly or register it as an
        ``atexit`` function if you wish to ensure cleanup of a temporary
        directory used for extractions.
        """
        # XXX

def get_default_cache():
    """Determine the default cache location

    This returns the ``PYTHON_EGG_CACHE`` environment variable, if set.
    Otherwise, on Windows, it returns a "Python-Eggs" subdirectory of the
    "Application Data" directory.  On all other systems, it's "~/.python-eggs".
    """
    try:
        return os.environ['PYTHON_EGG_CACHE']
    except KeyError:
        pass

    if os.name!='nt':
        return os.path.expanduser('~/.python-eggs')

    app_data = 'Application Data'   # XXX this may be locale-specific!
    app_homes = [
        (('APPDATA',), None),       # best option, should be locale-safe
        (('USERPROFILE',), app_data),
        (('HOMEDRIVE','HOMEPATH'), app_data),
        (('HOMEPATH',), app_data),
        (('HOME',), None),
        (('WINDIR',), app_data),    # 95/98/ME
    ]

    for keys, subdir in app_homes:
        dirname = ''
        for key in keys:
            if key in os.environ:
                dirname = os.path.join(dirname, os.environ[key])
            else:
                break
        else:
            if subdir:
                dirname = os.path.join(dirname,subdir)
            return os.path.join(dirname, 'Python-Eggs')
    else:
        raise RuntimeError(
            "Please set the PYTHON_EGG_CACHE enviroment variable"
        )

def safe_name(name):
    """Convert an arbitrary string to a standard distribution name

    Any runs of non-alphanumeric/. characters are replaced with a single '-'.
    """
    return re.sub('[^A-Za-z0-9.]+', '-', name)


def safe_version(version):
    """Convert an arbitrary string to a standard version string

    Spaces become dots, and all other non-alphanumeric characters become
    dashes, with runs of multiple dashes condensed to a single dash.
    """
    version = version.replace(' ','.')
    return re.sub('[^A-Za-z0-9.]+', '-', version)


def safe_extra(extra):
    """Convert an arbitrary string to a standard 'extra' name

    Any runs of non-alphanumeric characters are replaced with a single '_',
    and the result is always lowercased.
    """
    return re.sub('[^A-Za-z0-9.]+', '_', extra).lower()


def to_filename(name):
    """Convert a project or version name to its filename-escaped form

    Any '-' characters are currently replaced with '_'.
    """
    return name.replace('-','_')


class MarkerEvaluation(object):
    values = {
        'os_name': lambda: os.name,
        'sys_platform': lambda: sys.platform,
        'python_full_version': lambda: sys.version.split()[0],
        'python_version': lambda:'%s.%s' % (sys.version_info[0], sys.version_info[1]),
        'platform_version': platform.version,
        'platform_machine': platform.machine,
        'python_implementation': platform.python_implementation,
    }

    @classmethod
    def is_invalid_marker(cls, text):
        """
        Validate text as a PEP 426 environment marker; return an exception
        if invalid or False otherwise.
        """
        try:
            cls.evaluate_marker(text)
        except SyntaxError:
            return cls.normalize_exception(sys.exc_info()[1])
        return False

    @staticmethod
    def normalize_exception(exc):
        """
        Given a SyntaxError from a marker evaluation, normalize the error message:
         - Remove indications of filename and line number.
         - Replace platform-specific error messages with standard error messages.
        """
        subs = {
            'unexpected EOF while parsing': 'invalid syntax',
            'parenthesis is never closed': 'invalid syntax',
        }
        exc.filename = None
        exc.lineno = None
        exc.msg = subs.get(exc.msg, exc.msg)
        return exc

    @classmethod
    def and_test(cls, nodelist):
        # MUST NOT short-circuit evaluation, or invalid syntax can be skipped!
        return functools.reduce(operator.and_, [cls.interpret(nodelist[i]) for i in range(1,len(nodelist),2)])

    @classmethod
    def test(cls, nodelist):
        # MUST NOT short-circuit evaluation, or invalid syntax can be skipped!
        return functools.reduce(operator.or_, [cls.interpret(nodelist[i]) for i in range(1,len(nodelist),2)])

    @classmethod
    def atom(cls, nodelist):
        t = nodelist[1][0]
        if t == token.LPAR:
            if nodelist[2][0] == token.RPAR:
                raise SyntaxError("Empty parentheses")
            return cls.interpret(nodelist[2])
        raise SyntaxError("Language feature not supported in environment markers")

    @classmethod
    def comparison(cls, nodelist):
        if len(nodelist)>4:
            raise SyntaxError("Chained comparison not allowed in environment markers")
        comp = nodelist[2][1]
        cop = comp[1]
        if comp[0] == token.NAME:
            if len(nodelist[2]) == 3:
                if cop == 'not':
                    cop = 'not in'
                else:
                    cop = 'is not'
        try:
            cop = cls.get_op(cop)
        except KeyError:
            raise SyntaxError(repr(cop)+" operator not allowed in environment markers")
        return cop(cls.evaluate(nodelist[1]), cls.evaluate(nodelist[3]))

    @classmethod
    def get_op(cls, op):
        ops = {
            symbol.test: cls.test,
            symbol.and_test: cls.and_test,
            symbol.atom: cls.atom,
            symbol.comparison: cls.comparison,
            'not in': lambda x, y: x not in y,
            'in': lambda x, y: x in y,
            '==': operator.eq,
            '!=': operator.ne,
        }
        if hasattr(symbol, 'or_test'):
            ops[symbol.or_test] = cls.test
        return ops[op]

    @classmethod
    def evaluate_marker(cls, text, extra=None):
        """
        Evaluate a PEP 426 environment marker on CPython 2.4+.
        Return a boolean indicating the marker result in this environment.
        Raise SyntaxError if marker is invalid.

        This implementation uses the 'parser' module, which is not implemented on
        Jython and has been superseded by the 'ast' module in Python 2.6 and
        later.
        """
        return cls.interpret(parser.expr(text).totuple(1)[1])

    @classmethod
    def _markerlib_evaluate(cls, text):
        """
        Evaluate a PEP 426 environment marker using markerlib.
        Return a boolean indicating the marker result in this environment.
        Raise SyntaxError if marker is invalid.
        """
        import _markerlib
        # markerlib implements Metadata 1.2 (PEP 345) environment markers.
        # Translate the variables to Metadata 2.0 (PEP 426).
        env = _markerlib.default_environment()
        for key in env.keys():
            new_key = key.replace('.', '_')
            env[new_key] = env.pop(key)
        try:
            result = _markerlib.interpret(text, env)
        except NameError:
            e = sys.exc_info()[1]
            raise SyntaxError(e.args[0])
        return result

    if 'parser' not in globals():
        # Fall back to less-complete _markerlib implementation if 'parser' module
        # is not available.
        evaluate_marker = _markerlib_evaluate

    @classmethod
    def interpret(cls, nodelist):
        while len(nodelist)==2: nodelist = nodelist[1]
        try:
            op = cls.get_op(nodelist[0])
        except KeyError:
            raise SyntaxError("Comparison or logical expression expected")
        return op(nodelist)

    @classmethod
    def evaluate(cls, nodelist):
        while len(nodelist)==2: nodelist = nodelist[1]
        kind = nodelist[0]
        name = nodelist[1]
        if kind==token.NAME:
            try:
                op = cls.values[name]
            except KeyError:
                raise SyntaxError("Unknown name %r" % name)
            return op()
        if kind==token.STRING:
            s = nodelist[1]
            if s[:1] not in "'\"" or s.startswith('"""') or s.startswith("'''") \
                    or '\\' in s:
                raise SyntaxError(
                    "Only plain strings allowed in environment markers")
            return s[1:-1]
        raise SyntaxError("Language feature not supported in environment markers")

invalid_marker = MarkerEvaluation.is_invalid_marker
evaluate_marker = MarkerEvaluation.evaluate_marker

class NullProvider:
    """Try to implement resources and metadata for arbitrary PEP 302 loaders"""

    egg_name = None
    egg_info = None
    loader = None

    def __init__(self, module):
        self.loader = getattr(module, '__loader__', None)
        self.module_path = os.path.dirname(getattr(module, '__file__', ''))

    def get_resource_filename(self, manager, resource_name):
        return self._fn(self.module_path, resource_name)

    def get_resource_stream(self, manager, resource_name):
        return BytesIO(self.get_resource_string(manager, resource_name))

    def get_resource_string(self, manager, resource_name):
        return self._get(self._fn(self.module_path, resource_name))

    def has_resource(self, resource_name):
        return self._has(self._fn(self.module_path, resource_name))

    def has_metadata(self, name):
        return self.egg_info and self._has(self._fn(self.egg_info,name))

    if sys.version_info <= (3,):
        def get_metadata(self, name):
            if not self.egg_info:
                return ""
            return self._get(self._fn(self.egg_info,name))
    else:
        def get_metadata(self, name):
            if not self.egg_info:
                return ""
            return self._get(self._fn(self.egg_info,name)).decode("utf-8")

    def get_metadata_lines(self, name):
        return yield_lines(self.get_metadata(name))

    def resource_isdir(self,resource_name):
        return self._isdir(self._fn(self.module_path, resource_name))

    def metadata_isdir(self,name):
        return self.egg_info and self._isdir(self._fn(self.egg_info,name))

    def resource_listdir(self,resource_name):
        return self._listdir(self._fn(self.module_path,resource_name))

    def metadata_listdir(self,name):
        if self.egg_info:
            return self._listdir(self._fn(self.egg_info,name))
        return []

    def run_script(self,script_name,namespace):
        script = 'scripts/'+script_name
        if not self.has_metadata(script):
            raise ResolutionError("No script named %r" % script_name)
        script_text = self.get_metadata(script).replace('\r\n','\n')
        script_text = script_text.replace('\r','\n')
        script_filename = self._fn(self.egg_info,script)
        namespace['__file__'] = script_filename
        if os.path.exists(script_filename):
            execfile(script_filename, namespace, namespace)
        else:
            from linecache import cache
            cache[script_filename] = (
                len(script_text), 0, script_text.split('\n'), script_filename
            )
            script_code = compile(script_text,script_filename,'exec')
            exec(script_code, namespace, namespace)

    def _has(self, path):
        raise NotImplementedError(
            "Can't perform this operation for unregistered loader type"
        )

    def _isdir(self, path):
        raise NotImplementedError(
            "Can't perform this operation for unregistered loader type"
        )

    def _listdir(self, path):
        raise NotImplementedError(
            "Can't perform this operation for unregistered loader type"
        )

    def _fn(self, base, resource_name):
        if resource_name:
            return os.path.join(base, *resource_name.split('/'))
        return base

    def _get(self, path):
        if hasattr(self.loader, 'get_data'):
            return self.loader.get_data(path)
        raise NotImplementedError(
            "Can't perform this operation for loaders without 'get_data()'"
        )

register_loader_type(object, NullProvider)


class EggProvider(NullProvider):
    """Provider based on a virtual filesystem"""

    def __init__(self,module):
        NullProvider.__init__(self,module)
        self._setup_prefix()

    def _setup_prefix(self):
        # we assume here that our metadata may be nested inside a "basket"
        # of multiple eggs; that's why we use module_path instead of .archive
        path = self.module_path
        old = None
        while path!=old:
            if path.lower().endswith('.egg'):
                self.egg_name = os.path.basename(path)
                self.egg_info = os.path.join(path, 'EGG-INFO')
                self.egg_root = path
                break
            old = path
            path, base = os.path.split(path)

class DefaultProvider(EggProvider):
    """Provides access to package resources in the filesystem"""

    def _has(self, path):
        return os.path.exists(path)

    def _isdir(self,path):
        return os.path.isdir(path)

    def _listdir(self,path):
        return os.listdir(path)

    def get_resource_stream(self, manager, resource_name):
        return open(self._fn(self.module_path, resource_name), 'rb')

    def _get(self, path):
        stream = open(path, 'rb')
        try:
            return stream.read()
        finally:
            stream.close()

register_loader_type(type(None), DefaultProvider)

if importlib_bootstrap is not None:
    register_loader_type(importlib_bootstrap.SourceFileLoader, DefaultProvider)


class EmptyProvider(NullProvider):
    """Provider that returns nothing for all requests"""

    _isdir = _has = lambda self,path: False
    _get = lambda self,path: ''
    _listdir = lambda self,path: []
    module_path = None

    def __init__(self):
        pass

empty_provider = EmptyProvider()


def build_zipmanifest(path):
    """
    This builds a similar dictionary to the zipimport directory
    caches.  However instead of tuples, ZipInfo objects are stored.

    The translation of the tuple is as follows:
      * [0] - zipinfo.filename on stock pythons this needs "/" --> os.sep
              on pypy it is the same (one reason why distribute did work
              in some cases on pypy and win32).
      * [1] - zipinfo.compress_type
      * [2] - zipinfo.compress_size
      * [3] - zipinfo.file_size
      * [4] - len(utf-8 encoding of filename) if zipinfo & 0x800
              len(ascii encoding of filename) otherwise
      * [5] - (zipinfo.date_time[0] - 1980) << 9 |
               zipinfo.date_time[1] << 5 | zipinfo.date_time[2]
      * [6] - (zipinfo.date_time[3] - 1980) << 11 |
               zipinfo.date_time[4] << 5 | (zipinfo.date_time[5] // 2)
      * [7] - zipinfo.CRC
    """
    zipinfo = dict()
    zfile = zipfile.ZipFile(path)
    #Got ZipFile has not __exit__ on python 3.1
    try:
        for zitem in zfile.namelist():
            zpath = zitem.replace('/', os.sep)
            zipinfo[zpath] = zfile.getinfo(zitem)
            assert zipinfo[zpath] is not None
    finally:
        zfile.close()
    return zipinfo


class ZipProvider(EggProvider):
    """Resource support for zips and eggs"""

    eagers = None

    def __init__(self, module):
        EggProvider.__init__(self,module)
        self.zipinfo = build_zipmanifest(self.loader.archive)
        self.zip_pre = self.loader.archive+os.sep

    def _zipinfo_name(self, fspath):
        # Convert a virtual filename (full path to file) into a zipfile subpath
        # usable with the zipimport directory cache for our target archive
        if fspath.startswith(self.zip_pre):
            return fspath[len(self.zip_pre):]
        raise AssertionError(
            "%s is not a subpath of %s" % (fspath,self.zip_pre)
        )

    def _parts(self,zip_path):
        # Convert a zipfile subpath into an egg-relative path part list
        fspath = self.zip_pre+zip_path  # pseudo-fs path
        if fspath.startswith(self.egg_root+os.sep):
            return fspath[len(self.egg_root)+1:].split(os.sep)
        raise AssertionError(
            "%s is not a subpath of %s" % (fspath,self.egg_root)
        )

    def get_resource_filename(self, manager, resource_name):
        if not self.egg_name:
            raise NotImplementedError(
                "resource_filename() only supported for .egg, not .zip"
            )
        # no need to lock for extraction, since we use temp names
        zip_path = self._resource_to_zip(resource_name)
        eagers = self._get_eager_resources()
        if '/'.join(self._parts(zip_path)) in eagers:
            for name in eagers:
                self._extract_resource(manager, self._eager_to_zip(name))
        return self._extract_resource(manager, zip_path)

    @staticmethod
    def _get_date_and_size(zip_stat):
        size = zip_stat.file_size
        date_time = zip_stat.date_time + (0, 0, -1)  # ymdhms+wday, yday, dst
        #1980 offset already done
        timestamp = time.mktime(date_time)
        return timestamp, size

    def _extract_resource(self, manager, zip_path):

        if zip_path in self._index():
            for name in self._index()[zip_path]:
                last = self._extract_resource(
                    manager, os.path.join(zip_path, name)
                )
            return os.path.dirname(last)  # return the extracted directory name

        timestamp, size = self._get_date_and_size(self.zipinfo[zip_path])

        if not WRITE_SUPPORT:
            raise IOError('"os.rename" and "os.unlink" are not supported '
                          'on this platform')
        try:

            real_path = manager.get_cache_path(
                self.egg_name, self._parts(zip_path)
            )

            if self._is_current(real_path, zip_path):
                return real_path

            outf, tmpnam = _mkstemp(".$extract", dir=os.path.dirname(real_path))
            os.write(outf, self.loader.get_data(zip_path))
            os.close(outf)
            utime(tmpnam, (timestamp,timestamp))
            manager.postprocess(tmpnam, real_path)

            try:
                rename(tmpnam, real_path)

            except os.error:
                if os.path.isfile(real_path):
                    if self._is_current(real_path, zip_path):
                        # the file became current since it was checked above,
                        #  so proceed.
                        return real_path
                    elif os.name=='nt':     # Windows, del old file and retry
                        unlink(real_path)
                        rename(tmpnam, real_path)
                        return real_path
                raise

        except os.error:
            manager.extraction_error()  # report a user-friendly error

        return real_path

    def _is_current(self, file_path, zip_path):
        """
        Return True if the file_path is current for this zip_path
        """
        timestamp, size = self._get_date_and_size(self.zipinfo[zip_path])
        if not os.path.isfile(file_path):
            return False
        stat = os.stat(file_path)
        if stat.st_size!=size or stat.st_mtime!=timestamp:
            return False
        # check that the contents match
        zip_contents = self.loader.get_data(zip_path)
        f = open(file_path, 'rb')
        file_contents = f.read()
        f.close()
        return zip_contents == file_contents

    def _get_eager_resources(self):
        if self.eagers is None:
            eagers = []
            for name in ('native_libs.txt', 'eager_resources.txt'):
                if self.has_metadata(name):
                    eagers.extend(self.get_metadata_lines(name))
            self.eagers = eagers
        return self.eagers

    def _index(self):
        try:
            return self._dirindex
        except AttributeError:
            ind = {}
            for path in self.zipinfo:
                parts = path.split(os.sep)
                while parts:
                    parent = os.sep.join(parts[:-1])
                    if parent in ind:
                        ind[parent].append(parts[-1])
                        break
                    else:
                        ind[parent] = [parts.pop()]
            self._dirindex = ind
            return ind

    def _has(self, fspath):
        zip_path = self._zipinfo_name(fspath)
        return zip_path in self.zipinfo or zip_path in self._index()

    def _isdir(self,fspath):
        return self._zipinfo_name(fspath) in self._index()

    def _listdir(self,fspath):
        return list(self._index().get(self._zipinfo_name(fspath), ()))

    def _eager_to_zip(self,resource_name):
        return self._zipinfo_name(self._fn(self.egg_root,resource_name))

    def _resource_to_zip(self,resource_name):
        return self._zipinfo_name(self._fn(self.module_path,resource_name))

register_loader_type(zipimport.zipimporter, ZipProvider)


class FileMetadata(EmptyProvider):
    """Metadata handler for standalone PKG-INFO files

    Usage::

        metadata = FileMetadata("/path/to/PKG-INFO")

    This provider rejects all data and metadata requests except for PKG-INFO,
    which is treated as existing, and will be the contents of the file at
    the provided location.
    """

    def __init__(self,path):
        self.path = path

    def has_metadata(self,name):
        return name=='PKG-INFO'

    def get_metadata(self,name):
        if name=='PKG-INFO':
            f = open(self.path,'rU')
            metadata = f.read()
            f.close()
            return metadata
        raise KeyError("No metadata except PKG-INFO is available")

    def get_metadata_lines(self,name):
        return yield_lines(self.get_metadata(name))


class PathMetadata(DefaultProvider):
    """Metadata provider for egg directories

    Usage::

        # Development eggs:

        egg_info = "/path/to/PackageName.egg-info"
        base_dir = os.path.dirname(egg_info)
        metadata = PathMetadata(base_dir, egg_info)
        dist_name = os.path.splitext(os.path.basename(egg_info))[0]
        dist = Distribution(basedir,project_name=dist_name,metadata=metadata)

        # Unpacked egg directories:

        egg_path = "/path/to/PackageName-ver-pyver-etc.egg"
        metadata = PathMetadata(egg_path, os.path.join(egg_path,'EGG-INFO'))
        dist = Distribution.from_filename(egg_path, metadata=metadata)
    """

    def __init__(self, path, egg_info):
        self.module_path = path
        self.egg_info = egg_info


class EggMetadata(ZipProvider):
    """Metadata provider for .egg files"""

    def __init__(self, importer):
        """Create a metadata provider from a zipimporter"""

        self.zipinfo = build_zipmanifest(importer.archive)
        self.zip_pre = importer.archive+os.sep
        self.loader = importer
        if importer.prefix:
            self.module_path = os.path.join(importer.archive, importer.prefix)
        else:
            self.module_path = importer.archive
        self._setup_prefix()

_declare_state('dict', _distribution_finders = {})

def register_finder(importer_type, distribution_finder):
    """Register `distribution_finder` to find distributions in sys.path items

    `importer_type` is the type or class of a PEP 302 "Importer" (sys.path item
    handler), and `distribution_finder` is a callable that, passed a path
    item and the importer instance, yields ``Distribution`` instances found on
    that path item.  See ``pkg_resources.find_on_path`` for an example."""
    _distribution_finders[importer_type] = distribution_finder


def find_distributions(path_item, only=False):
    """Yield distributions accessible via `path_item`"""
    importer = get_importer(path_item)
    finder = _find_adapter(_distribution_finders, importer)
    return finder(importer, path_item, only)

def find_eggs_in_zip(importer, path_item, only=False):
    """
    Find eggs in zip files; possibly multiple nested eggs.
    """
    if importer.archive.endswith('.whl'):
        # wheels are not supported with this finder
        # they don't have PKG-INFO metadata, and won't ever contain eggs
        return
    metadata = EggMetadata(importer)
    if metadata.has_metadata('PKG-INFO'):
        yield Distribution.from_filename(path_item, metadata=metadata)
    if only:
        return  # don't yield nested distros
    for subitem in metadata.resource_listdir('/'):
        if subitem.endswith('.egg'):
            subpath = os.path.join(path_item, subitem)
            for dist in find_eggs_in_zip(zipimport.zipimporter(subpath), subpath):
                yield dist

register_finder(zipimport.zipimporter, find_eggs_in_zip)

def find_nothing(importer, path_item, only=False):
    return ()
register_finder(object,find_nothing)

def find_on_path(importer, path_item, only=False):
    """Yield distributions accessible on a sys.path directory"""
    path_item = _normalize_cached(path_item)

    if os.path.isdir(path_item) and os.access(path_item, os.R_OK):
        if path_item.lower().endswith('.egg'):
            # unpacked egg
            yield Distribution.from_filename(
                path_item, metadata=PathMetadata(
                    path_item, os.path.join(path_item,'EGG-INFO')
                )
            )
        else:
            # scan for .egg and .egg-info in directory
            for entry in os.listdir(path_item):
                lower = entry.lower()
                if lower.endswith('.egg-info') or lower.endswith('.dist-info'):
                    fullpath = os.path.join(path_item, entry)
                    if os.path.isdir(fullpath):
                        # egg-info directory, allow getting metadata
                        metadata = PathMetadata(path_item, fullpath)
                    else:
                        metadata = FileMetadata(fullpath)
                    yield Distribution.from_location(
                        path_item,entry,metadata,precedence=DEVELOP_DIST
                    )
                elif not only and lower.endswith('.egg')# $3`N@Fo &AoydBp0?ZoS#SKp`CK $60.F +h/0 + )0 + @`1F"0D5(FCD5O(F! $*h/0 + dE>0 + (F9(F! $	@@7 + c1+ (F2 $(F "L $(F"F $(F"@ $1IE ] + #(F1F2	 3	 #(F1F "0 +@}0 + x 1F u<+hOr[j0Fk` $0F"Y $} $k
FF;Ikk0FLk[lP0lRlAf+h>0 + . + *Yn ) &0F". $R0Fk"% $I0F{" $@+h~ + (F1FJF(+h!i $.(FQFJF3FlF (@<I7 sh o@++++@A(F!F9(F!FW8h o&  c
;+I #h#h
;+vI #Xh#XX  8`+kQFie3 JF3Fw<F\J]m ,m . 3h*h ;#?0]I "(F WI#(F SI#(F q(FF (i\2h3y!s (C:U1FJF_v~\U!_qF (dQF2FKF ^F	 QF2FKF  F ,P**++hfI $GoDoAoO4oooooo
ooooooooooooL?DO FgFp ) 6 -AFFFF (F1F:FCF -O #FFwvrF	!F0hBF 6 (C0 +""}I  0i1CF
h 0iI 
X("wc)v"Zw,$vQ#O [ c         ] !        3 # ? K       u        U a       ; M       i u                 ! [  [ ? K  [  	     u    /~ ~ ~ 	      7 ) 5 c o            3  m E  [  }  g  c       =   = U             S           C ; G  + 7 E S a   u  s   E           ' 3      % 7 C O ]    1 U  c    s   s    ) 7 E [  k {                                 m           ' U          )  E 7      S    !  )~         k        y  }     S A    5 A S _ w    !                          % 5 9 I a i u  M ]     =      _                            W                #      / 9   E O G Q U _ k u            !             %  [ C     c     =                      +  7 - 7  }           m w      1  ;                '  ) i 7 _  $kXl o&  c
;+I  # h# h
;+I  # Xh# XX    0F!*F #kl o&  c
;+I  # h# h
;+I  # Xh# XX    !0F*FFP~kXl o&  c
;+I  # h# h
;+xI  # Xh# XX    L0F!*F #Ckl o&  c
;+cI  # h# h
;+ZI  # Xh# XX    0F!*F#3kpir (B1p +O C #C 03k% A)(!i:T  <0
8 ;#"@Fp
D"  p"804y "<0;4 1"D0 +@ ) "   0$0"0"8 4@ (<0!

Bf@Fop  (i2jphkBph!cb (U2AFjkaLD  *G:B4@@F1O:"$3B"H+"@F	q8#"pAF1p+o	p !Orp $
"pADHD14pB2 #J6"@FJKKB * &0FAFMHFAF'6 0-zV3h[k +uS0Fq"F@F!F"3h[k +buAF" F0Fq"FIF 0FCF      ~0FAFwB2 0qBBm !@FtAFatAFZb0 0T0HF)bPFHF#BHFHF}<0 +BbP3 !@Fp#0FIFpRp 0!wQ13h/0 + IFr#6
ph  0F<   )phF (!FHF!F@Fph!F*BphFiF (AF #

@FQFpo  TB
(p + ##
)o + ##(FIp(HFAFRF^(FIe (BHFAFRF*)(FYD"F,(FIL ((FIF (0c
0FIF$0FIF"ph)F^@ ,B,Aph0 ,@0@ (Iph,  (0L70 +	"# X b0 "AF0F= FX b0 0F
0F (@ ,0Bbx@F2!Fcx "CDpX0 00FIF*F" FAF#h+o4xAch30FIF"F0tF0@jAjco0F #o4tIFbh#h (At )y#hB@F1"`0 0`@6 0}s@*B* "d$6 0^$VZ^0 \0   LF  -	O O\ ^0;+#O \0^@06 0*aoV"0 0P0 0@p7 0pWt7 0tGk+0R02 03h[k 0k+2h/0+?#Sc Ucw? !sD2#y2Zv1 )0hC0 +Ck +AC00@ 00,C0#01 0A1 03hA/0 +)0 +0F 0F!`{@S@Bph@ *<1VF (% i0; ap0F!F (A%Q0 0Kk#0HF!@6 0:-V36 0-F)0 +0#o0FIFa (1 0Q	3h@F" 3h ! "Z3hO 0OY2 ;# 0B6 0V3hm 03he3h.0 03h.@a0 0a@@F	"0FIFBF@Fq"1 0,0F (LA0F1{0FXX1CH8   r #8i3hn@"F@Fy^3hn 0X0F3h@FO9r`K07h 0D0` -> #C``90FAF23h0F)F "~4(0F !   3h0F)F"~"0F!  NE
N5 03h0F@]!00!00!00 #2111X111d#d1110111a#a111c`B5 0BE1h$m3B]H+m@FImAF"ww )M#BA3heXm3hE0# 0{ 0w0F)FFp3hF0 0i0hE0F@^D60 0VD60 0Nk+---Aj0F!2h~#>0 +A70F2D6y 0+D60 0#k+-Aj0F!2h~#>0 +A0FD6	0 0k+--A0F!je3ki4 0T3hL0 02hE0o k+-AL0B0Fi])Ap0 $ 2@F"0 +o2hE0\L0 +W*AKtAF" F0F!FJF (X3h~ +0F0F!a|4x@ 0s3h -! !E0"0F"a4@&x@C ## 0R3hE0d1y ,ACx+[!F0"!F1xS+o *z#y<cxBBxx[5 F	0F!FF*F0F
4j 04b0Fi  0F)FR0F  0F!Ff0F  0FIF*F (0F  0F)F0F  0F)FL6x 0L6[x 0L (`1 03k-iQ?L6 "ZtL6!"ZtL6!L&w1L6y[xCw#$@C 0FVi0F)F " (A`LBxxBAtV#CtRL6x 0KL!0  @L6x 09L6y 020F)F+1 0%k+-AQ$@  4@#C 0
-0F)FL60 0k+A-A4 0-3h0 -A0F4 0 04x 04x 04  00C	@FM"8@FM1"1 0=1#o3h~ +!0F!Ob0F!Br73kiex1 0r3hQ/0 +j0F0F!Fas0K !"8FpI"8Fi # _ 0 @e o <"XAFF @o Ds XAF "#_ ,A(@e o Ds XAF" #@o ,As " XAFF0+	K 085[ 0 F (AX!F3 (3h/0# !F2h~Sj+3kpB[h_ ""B#1852h\G~ +>0 +A3kiB!F0F0F 0F!F0F04kK	SpC _8#<#XHF" C# o 0C 0cl + 0C C 0clOr 0CC 0j01kK	cpC _8#<#X0F*FmU-  PwOzr40C"hAFQh+i?Ozs0F4H&3h~ +0FIF "CF2h0 + ~ + uI"(FAF"o"p(F"	pTd!ySi+3h>0c0FIFo#F t 0FIFre 6 0 F ;h 0 =`HF @FI W FAFYh!Fq X0BOX|"F@FX XgFXbt!FB  {sLs)0 !"01)0r !"01s*FAFwF"AFq1 +@9+O4r"_xxxY1 +@!#C#C	Cd1s#XWXr#Fx ,@ 0Fd`0s"/EE d
4 F0B@@F!FZ 4B0 +, r !"(FO(FAF"F , 0F)F ( `
0)F" 0F   a@F1" U "pAFp+@"p"y1++@7 d! Fx, @  
# 0F #_h#57#7 p7C7# 5;5 b"pAFpp+@C"yfp"_$5KphOa$ ( 1+;05,5+@ T(5hB "0F!#  ,5(5" #T8 050F # 5 !*h4#5; 57#7 (@"@F0+p@0FBpp;pp 5Bp0 5+(5,5 53T8# 0 0+,5d+
T("5hB # 0  (@0F! CE C5 0 AF"H"H {Kh 0Kh0 q
0 0 k
0HF! b1 0 \3hQ~ + U0Fg P1 0 J3hQ~ + C0FU >"0 0 8"P 48540 0 ,- 3h/0 -@854P 0F)FS 0F)F.   0F)FB 0F)F)   0F)Fu 0Fi   0F)F[ 0FO   0F!F  !@FOr2HFAFrp 1 0 A 3h=0 0 3h=@ 86 0 8F AFy"1KHF S+ f*=
hjhBDphtF ( Ci;ahhhi8h1h"N1 kh+8FIF"{5L0F#hAFC#` "#h##` Xe,@
"lbph5F (  i1h ;N1"=a0LIF"(FG "#+sjsFj1O3)s F"l44tBL0F#h9FC#` "u#h##` |q 	{y 0 ;y 0<qF, $ ;k@Fww=cj@Fwwbh@Fww`;i 0;a1a0 0PX0 0XPZ0 0Z@0 0
F+ d	0Ozs PHF&0
" 0
@sB A
#&0+0 0+@|t8 0wtXt8 0oHl3k[h 0g,0 0b,@_ !"c $#0Fqcq#dz$<T<d4B@Fc"S>0F!Ft9l7 042@Fj"A,BakQhihak #cc80 %0PjAF")jh + hIJF+F`c- k+B@2HFi(2 0H7 00FKh 0K`U7 0- UW|7 0
( |h8 0hXp0F[lj8 0d- gjX # 0e0 0e@0FIFBFQ3h %h6 #5 5 ) 3hh ( ? %x %B% * :@F~i+ }r1[;r #q]{z 0Y3h 0x#; 0N # 0J3h  ( x + )wB@ 83h>02858"hB@F@+!"h43hE0  "&6(" ! Fm!F0Fq"hB@F@+73hE0  " 03B6 !(" FAAFQ+7"`3hE0 "0F!F,8 0 ,8  #-8 # 03hiP0FJ  F   p 0FO10F:  0i3hi 0FJ0FO10F@0i}8
" 0u
#8ohy+
0F# ^0F# T$5 0O$EL%EI%5 0D2P?20 082y 022q.   ')F w )@ ?- 0i !*F# f" F0FAF"F0F)F0FpoWp 0o00F)FR0FIF$E, !F0F@@8 80 C#  @C 0FIFCc0FJ (nl1 0AF"lo" F!F0F3F (Vo0F0F0F"F (E@0F"F@F!F("`8 0{x8 0vz@xo0o h0$#S0`CS0[8 0V0S 3 0MoIoEoAo=o 9o5o1o-o)O0%o!oooo$ oo	oo{F # 3:FC- " F#. 85p]F@c@o"hE0pAX_ !!(F?F(F;D0d(OPO PC13h[j+2kpCRh_ ##BX!FX)FpC_8#<#X4kX3c!4cF(Fp-AhF>0vF+h/0S@7;X9F"  "(i9FSV!(i1@  +(i!@  !(i@ (F_1;(iL!(F+(F &DB, F F~6.+h>0 "DPyC212*(F9F(Ft!f%1Br +Ob(F!+ki
"Fd(F#f "(F@+(F+h[k[6dC6 !	(F|a(Fb|A(F![ C|@(F	(FH(F}(F7Kh !D3#11FO@v1F(F3D2# C2" "C2"po pc"pbC22 pBC"46,+h(FL*h~/0 !D"y #q1) #j2 Rd!F p %FQj)Fj" i@tVpFpGF pG-OF7FiFF(i ("xcxB#C SB## S#p
cpcx"xB&+#+ ## /PFAFZF@ _#0 @sBS00 +##0 ! !C#030 
PFI[F #0Q 70J\7 "i  1"# = >Fx p7FiF0 (F!F KS" (F!F # p  FFF7i0 +030+ F07iF0[0C3000-AFIFF@: #00FI*F$*F0FIcJCc\*" 20F)F(#h  # #`0 30e Q  pF $+D(yy4 ,pFF	ihh17i7jFm";#2 m2(io?0C~(F!F(F!F0S0;~(F!FF (>B  @N_#B   pG-AFFFF"k+   b   b  b  b 7 b  F ( e *@d!y +@Si+ 2z +@6h@ F (  F6h@ZSh+ + + FF Fidy#	!o(FCi+ 6h@JSh+{+y+X FgF F@OdCi+f-
-y +C 5+7 (Sd	!-.y ++-H 5+7?	!0F?:Sh+0+e)dys!	!"Sh++d1yk+			 "" " # F9F3 (  
O0o o o F-OhBFF(FFF !a`0F+kri|	rB	(F(F!F(F(F8*h/0300 <(F !2FO3 40(F #1F"[FE-O)FFFF@hb9  F9Fj2 +-sh+*#ki	2[B! FU Fh	;+ FFq!-h1h--OO  3l Fsl9F "	"SF --3B8FO8FK-OFFFhbcZh*O 
01rKO9\03#!Ox	O9\* 0	z70
z	1q90 ++lI#hOAhYFF ( l+  1FF\`Fd0#\0"00
1lEFFO X#1 F#h~ +fh2+
yC8 6B1  !BBPh' F(Fxh#` O2FQF
  ` d O2	K& "
3F	F0(F1FO7!#hZFhS #1 F) F)F#Fx, 9 #z0pGpF hF h !CD23Zi"hB #`1 )dh+;)Y)@h" #+Qp HpG  HpG F &K(F\ 9F(FlF"IhFm40Or0(F@c@oBB 9FC6#.F  0F-AFhFhF 1F F)FY F Fh9F*FCF F)F.iO1JF(Fn0(Fhm;O6O6l	+m(n! !O1((FsJsL
 
<(1	,8F(10C+nj@SBo(ndKk+JBJB# !(" % !
F(n*F(FN(FO4#(F!
 (F!"j(F\!
"eOsJJ 1(FIIjO C1C1OC(1!tb(FG(nv8!6(FD >(F!T 8(F!V 23K(F`1`10D!d1/K `1`10d1(FF! 66O6 #dFhK[hG4,Lh#mGnhG+nj@SB(F!@ ` !F(F@!F(F8FF IB W  @  @    ,5 @kpG-G %@FFFF.Fch	'HFGcz63$h ,  `(FFFI"F= F$SCSJ\+# 3"F	 sF &DB$y#yiB0s~
~h@(FF (6 .|-O0Fh 0]jC 3 00  "  +m2Cm20FhF##+V<F	FLiFCE(F"F* hh!F"O	"F<B[< +

>;E (FhFFF?!jFFX  3 #B F"o  FiF"P&lz0F4)"F-h6 -(FF)-OFFFF39F" &=<FF,&)F"hFky 3vDE ,  `   o -OhF"FO 
%F5")FO o"+qky@jycz&hB )F:FUp0!FB` `Xh:F4F ,o
		EPFFF"FI4 &"!FhFA 8Fo"#q"eyo 6B  FpFF0B)@h"0U(FI@h10o 0)F"  p "	#FjFd2B
yCm30o    pGF-O4FFFm xRU+iS+z+(F,{ $ %,F1+0FAF{JDUd2E 0 +@0 + (F (@	 ZoJi;{+ G#0(yD5OHa0F1"F%O4 -a
0F#ZF1 +>+z+;4 +7X02y)+/+-++	(FG(0F)FF  'IF:F0h ETD !F#0FIF:F0h E4TD !F0F#+z+77y+0FQD$#
0F*F#0-5*+z+"3 $8	$[8q	0F 4
,	Hq0F1!0F	Iq!0FAF*F"0Fr"F 0F !OB+z+?;=F~, 27FF+y #2 !kD"ZyKy;|+Bd2B	1 )!(F" # {>-OFFF (M
yFLF1F  KoT/1B?0Bb0m7o?[o}
|BZo2BPF1F#FM\g7g %t0@3BPF1Fy@5Bt@		pF|G -%%C! F*F/p-O*FFFF* **o	"o	F (8d2BOKo4Kg "FF yFOZlo, # |! *""#8F 	x2 kgny28F[pC_ $$"FV 8F"F8Ft  ( " h;h[j+;k8FZh8 "1Ph@ x2`P `8F SFx8F1FC 	x2 `d2By48F1FJFFO xR !lzOr(FlrBF FY_+a"(FO #ks> $z#+r+s3ss!FBF 2 !FBF,+}#+r3+sss+}!0k}"0}#0V++r#+s3s#s FBFF#+r+s3s#S+ b0+o	#+r3+sss)"+r#ss+z*s+#js#+r;+s 
Shy[8FO(Cho#+s#ss#ks+z;
+
 ###Os c3o?ZoS#SkpCk[EO33g8F)F+z+,b0(Fmh"p !F&(FWF!F*FF!F18FIF2Fd2Byk|[(F882#8Fy2Fy0o(F%80Fg"Fg 8F1FL0F(20Fx b0@+s|h0F
FO 	`o	HFF-AF8FF (1By@F1F"F;F$xBB F9F"#i+@F)F2F8 0~#@F)F"F"!@FF   O0FhhpGFhpGhyhs 
# h #|'F7hh(F(F6B(F $+D8y+y|4 , !
FF(F$(F!Ob # G !F
F (F $G(FA(F+ki_(Fm2A#m2+DpyayS"x+S~x4 ,(FK(F>FhFiAi 0 8iZFQFJFAFhhAhhiiHh )hFG  
IBbC@IBaC@I@ (I
hC
`pG        @    
IBrC@IBqC@I@ (I
hC@
`pG      @   I	h"XpG   I	h"PpG                                   Jh`pG   Jh`pG   I`Hh )G  qHrI "
PhqJ
@qKBj@#BnJhBmK|FmJ#@B	lIhlL#@$#CPhC` GiO@?B2 #FFgJ
@!@fICXfL@fMBFeMEFdMBFaMEF$#@`L%@-
+CF #EE\K:PF B@F B)!AX
h#@++11QK@QLB F FMLBh;L#@$@F F FEI!"BP/JDIX#BQhBKBhAK@jBF>IXB=IX@B2KiBIF?B#X$@6KX$#@ + @F2I`HF2I`PF1I``F1I`1I`1M1I`=F C#AB	$ +M,`kF*M+`;F)H*I "B                    $                  p        *         8                 \ d ` $  h"1@*J@F   h"1@*"BJ@F    HpG0 F8jH F& qFHO`? K !("Fd
K#`
Kc`
K`
K`
K#a
Kca
Ka
Ka
K#b
KcbF    T T $ $     D -C `V`Hv@~sv36~r
~t2 4#

UH+F&RK @h P~p~r0~t~u
245
 

FHDKEHh 0~s~r3
2
 3F=K>Hh=Kh=K:hB<H$2h7KB3B5K h 9F-H2F*L h (4##h=\OaD4~s3 ~s3F)F3FHKJhh~q~r1
2 H1F
  p   P  # <  ] t KATSw x    4   t  pF@k;kw 	,j(Fa; F)FAK(F+aK(F+all%Fph F (FKhL6BK"hh B   ##`FH      KhC3Cr#rK`pGF -Ah+F=Kh #Sa=h+jlylhhl :F)F3H2K~lhi(<j}j9iziOi +Hkk=lj:k{k %Hh1hrhh !Hi1irii HH $'F%FrY*BKBBH)F75/4DEO=ptF K \     ( =  K@hh dF pFKFh@BpF  NhF5x)F"F!F!FH.Kp#3pKhxK*FhO=x	)F"F!F
H!F#5p;pF 3     e pFF-@*F " F1FP FjpF j(0KnG,5 pF %1Kj0G 54-  p,5 JiadpGFil  ppGF}pGFBh@B  i[h   pGFiiAs+S+O0 r i*hCs`  h#s`FpGFFkF@iO a%26`i FkFO a@i62`i F-AFFFFI&#@imCe1k!Bh1F:Fj|2Si 0#i Fik  0 ! 2F F9FpRFM50!*F"iC%1#1
 
=#i1 ?	-ppFF1i1C10"`ihC# 60(H)FpFU !J pjF@i@#d#~28 #~2#i!ic	+ F? F'/#i[h F FRpF h1#2FF;pCxKpSXx\SxC #p
pcZxXcxC#q
KqxCx C#q
qxF;CxKpxxaC#cp
KpyJSpCyQKpyJSpyQKpBzzLC#cpa
KpzzLC#cpa
KpB{{LC#cpa
Kp{JSp{QKp|JSpC| pFxF;CxKpxxaC#cp
KpyJSpCyQKpyJSpyQKpz	 pFx
F;CxKpxQSpxJKpyQSpCyJKpyQSpyKpz	 ppGFx
F;CxKpxQSpxLKpyByaC#cp
Kpy pF xO pCxKp Lxpxp1 "EpF xF;CxKpxxaC#cp
KpyJSpCyQKpyJSpyQKpzJSpCz
 phpGg HpGh yFpGFpGFpGF@hFsFP #FF]1Bc\o  mKBo " 	Io 	 F"#3`(F|F2 pF h)F"Xp !qF (2; !`h Q)`h #1)`h #1psJKF )FF h)F""p !;F (2{ a`hK`hZy1F+F  |)  z F
F@hRF1F+`hmp !F (sJFK (FF)-2c QMK`hZy1F+F  QMK`hZy+F QU
K`hZy+F  FKy|F)  z p
FF9@h !p #1 p2 h!Fh !" i"*i#``h *FppFFA2+*F@hF61b6"" 2B*Fp !%	IH)F h"F %21`hjpI	H	IH)F h"-5F(Fp = Y s 2F# #2"h}#2h1BhF1BhF!hF"hF-OFiFF$)`@@,@8h1 F (  i
;+      D )FKJH )F)FO 	-F)FPF# -F F)F-4E		
	
KyExh ( `KLJ F )F)F$y-O 	)F@F#	-F F)F		-4
E	rI	#ESlKyB !kH	# )Ft* B  0)F"1_H _H)Fd-+,8h!BF ( i!
,8h!4F ( i!+F ,@8h!"F ( i,p3iI0+@01!)0 +@) @ ,@p!FF (@2 + 8h!F ( iOpvA)0+@h !%Js)E0	+p !F (Y#18h!F (p0+iJ#`"Z`C+A !8FOzp8F!Ozp0F ) z     (  )>P -:@8h!FzF (H(FH	A"F0i 8h1F0B42F ! )0	B
 O1O h * &    0	H&8h1F"# & 0 VF0F	F Fhh0 ! 
FhiF!FipN@0h BF0h)F " ?! "0h  1B0h!F " 0Hp8  N  HpG ipG @ pGFR  bZpGF#	C CAC "a 2i (KBKB_@pOp  I + pGo pGF9-OFFF)	/7 o Yi*Ci "io#3`o @3h+#3`j$i oi@4`3hB4`o Fh  !Fh a 'F(FIFd+ 7BhQF O4`  FK "ppG AtpG@|pG[FF $
F ".x,+24x + FF7F@F $F "B	x,+24x +  >-GFBxFFsBF$p 
(F2F ]B0 0   0 0   7F# LK	-#F>F; y  pGFpF 0x#}F%	 !q`j "f! FF (% )F_p "`&Hd&\"pB Rd&"`&d&	H"R\"@BRd& 6Cc 6pGF 9 pGFpF * !F F o F)F k pFpF  !F(F _jL K(F1FF T Fp  'pF  !F F A F)F =HpF -1pF  !F F / F)F +@t`p-AFFF  !F8F Fl	4
 9
<6B	,8FAF   -A`F @4 !FF0F V6FBVBp
&60FB&9Fd" 0 KhF sFFkFO aF *FF3F F F  |p  FIFF !
FF  I !
F,`0`pF   pF FX(F C1FF(F (F!F pFsFFF Ob !O3  F !@Tb3F  |F@mpGf0 0fAffe #CfpGFT3 pGF0   pGF pGFi`pGFO F F
0BE0EOpFpGFO0pGF  pG  pG  pGi@ppG   pG  pG  pG  pGpFF*FF FnOzp$pFFF F~FAn-AFa0  mB nGF  & FamnF]0 mB n1FG8FFFZF FFFPF FnFAn-AFa0  mB nGF  & Fam7nF]0 mB n1FG8FF sFFaP ,Os # (F !OrOsN
 
> $(F!FOr#F 	.(F!FOr#F | FiF _FF+? !OrOC si"+#JB$$OrDD%EOr0F !#F GOC0F !Or   UUCi
+O0#  !$"#~FFCiF
+	x")|")" !sF gO0FFFT	Jh@hD#!@ p" !#FLF   !`"F A-GF !
FFF(F !
FFF(F "F!(FFloFh~#yh +SF;F CFKF@B!hG$i ,(F!F:F;F+FFT	Jh@hD#!@ d" !#FF  +FFT	Jh@hD#!@ h" !#FF  +FFT	Jh@hD#!@ l" !#FF  Ci+"$+O3"#@;)1B8F @4b !O3FKh$ ?pFhFo@Bh+ oB Fn]0 mB n1FGpFF(F   FfFCi-C"+FF@ ( / ho"
@B "h+ ""_ 0FO aBFF (0@UyO 	j/CbkCc0F!01#01#B01/3 #0101/#01/6$ !Or#F0F D#  !Or#F0F(#  !Or#F0F#  !Or#F0F#  !OrO30F0F !OrOs 01#pC0101#01 0FIF  %(FpF (9ho"
@B "h+ ""M FO a*F`0@P &01#01C01+ F ![ F1FpF-AFhFoFF@Bh+ o5`0@PhB0 PanY0 mB nG8`0 F3`)F "-wA "!FF $F!F("#F(F !FCF(FO2(F!F("O3 ~F HpGH Ch.0oFpi+iBj	h  &khFh#F!F(Fh!F2F 8 pFJF JFhIKF q *  ChF~3h~bh # 0FpFchh~ &FEch1x#K*FhH0Fp @kpGi 0@  	pGFChFXKh&h"#hhi[i+#Cq2z#Cq3z#Cq<3z#Cqh3z#hhi[i#Cq(0h+CqCy+4F!q:OcB8Fqy)#B(FqF FO O 2,#8scD "2O3*;3332 3,0 F,"0 FOc((  KF1d% 8rrD3	 $K[h	B,#2OaR3+(#p400p #""pGF0FFGp0	\J ##h##h
J ##[h#X
O AC|lB(F0Fp x"m3epG pGhph &A`F	FhE00FAPo pJhdShdhCdh2dK0BpGFp   FChXy (@ o& c
;+I#h#h
;+I#Yh#YX"@S[rE
"?+?#    p #"BX2; pGFp#F2F +ONO 2FBBKBO0N(hI #S(hB"F  pF-G!F hC dh3F4FO 	K9F r{"2")F0h"0h)"0h"0h		 "0h
5
4 h#hA0-0+	 F!Or^ F<!
" F!O BT F<!"O-OFD0FmRFF@# &pFp!F (?io{#p"eppp 9i"
 1{C	3C#t
SpO
p
p	#C 
;ih# 1FXFh;F ( &0FF-GFF0xFB V0Z3B?Z0xCDp3x	 CjCcCbxFC DC0!  @$s]CsUV@1xllK]G3  -A FFF'x$ yZPE4sF#FBFx/0BxBj[byBxB#k[#c+Ft@F   FSx-AFF +8V0T@3 ? %k?BD0CL0C+T0Z0Z0#00F9F #-A #FFpx1llK]G x$F ((18hh0ihFhO sl h-AFFF	ihhO r)Fx4hHiRk;B0F)F "SikB0F)F"O s=F-A0FF@a2F !P2B #P212
)xh!F"R0?T0?\0?,LO   R#@C 0D  R
 0 #qx;p?E sh0FX"F sh8FX"Ff@!F " -A0FFF +xx+u01+q+30#CT 
F(bxZ0 ?O6#L ,KA.FK?5uE? #0@C6{z3 O3Fx8h0F#0#8hI"F+FI#x"m3e0\`30#0{z+8h!"F	  	 -GFF ) Kh/ khQ
@ , #x+ F(hT0bx Bs ?DO` Fd 0B!$#C 0L B 0 #qx ;pkh(FX"F1x"l3d+hh/0+y3q0C3?00^ 30"L0(FC0 "!F(hQF"F6-A?KFyFF (BXB8O\O\ ox"
T0bxBx"l3dl?cDFd"@OL C\5CCT?eE8F!F "sX0 A^0B
O ^0K?0Cg  !	B^0B+S1?BO?#"@L C\CCTx"O Sl3Sd0C3?00^;00C^ B!F "8F/0O C3?00^;"@!L C\CCTx"l3d  0#x+ 7F !"hF